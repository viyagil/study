# ES6+
* 프로그래머 능력자
 - 복잡성을 관리할 수 있는가.
 - 모든 프로그램은 변한다. 향후 일어나는 변화에 대응 가능한 코드를 짤 수 있는가.


## Language Element & Flow Control

### program & timing
컴퓨터가 무엇인지, 프로그램이 무엇인지
이런 근본적인 질문에 대답할 수 있어야 한다.

* 프로그램에 대해 알아보자
 * 컴퓨터 메모리에 적재되어 실행가능한 상태.
 * ex) 엑셀실행파일을 클릭해서 메모리에 적재될 때 …

* 프로그램을 짜기 위한 라이프 사이클
 * language code // lint time 
 * machine language // compile time  : 모든 파일 검토
 * file
 * load // 적재
 * run // 실행 - runtime ( 런타임에러에도 안걸리는 경우가 있다. -> 컨텍스트에러. )
 * terminate // 종료

* 런타입 스크립트 전략
 * language code // lint time 
 * file
 * load
 * machine language // auto compile : 바라보고 있는 파일만 검토가능,, 부분 코드만 컴파일 반영 가능.. 부분적 컴파일 -> 책임이 커짐
 * run // 실행 - runtime 
 * terminate // 종료

* 런타임에러는 못잡는건 알고있으니 스크립트 언어의 개발론을 따르자
 * 런타임안에서도 레이어별로 세세히 나누는 전략 , 에러 날때 그 부분 확인 가능
 -> 이것은 격리 : 복잡성을 정복한다!  
 * 격리하는 법을 배우기가 어렵기 때문에 프로그래밍이 어려운 것 -> 훈련. 훈련

### lexical grammar 
* control character  // 제어문자
* white space // 공백문자
* line terminators // 개행문자
* comments // 주석
* keyword // 예약어
* literal // 더 이상 쪼갤 수 없는 값

### language element
* statements // 문 - 공문, 식문, 제어문, 선언문     단문, 중문 
: 자바스크립트 엔진이 어떻게 해석할지 알려주는 힌트 ,, 실행명령? 단지 힌트이기 때문에 실행된 후에는 깨끗이 메모리에서 지워짐. 어디까지가 문이고 어디까지가 식인지는 js개발자가 정해서 만든것…ex) 루비는 if가 식
 * 공문 - 아무것도 없는 문.. 그냥 된다는 것만.  개발자들이 실수를 많이 해서 생김.
 * 식문 - 하나의 식은 하나의 문이 된다. 
 * 제어문 약 28개..
 * 선언문 - 제어문을 제외한.. 식별자 선언?
 * 단문 - 하나의 문장
 * 중문 - 중괄호
* expression // 식 - 값식, 연산식, 호출식(함수호출)
: 식은 최종적으로 하나의 값 , 값의 확장표현.
 * 연산자의 분류 - operator, operation 둘다 사용
  * 연잔자의 목적에 따라 (산술연산자, 논리연산자… 비교연산자?)
  * 연산자가 받아야하는 항의 수 (2항 연산자, 단항연산자, 3항 연산자…, 다항 연산자 = , )
* identifier // 식별자 - 기본형, 참조형     변수, 상수
: 그냥 값은 소비되서 없어져.. 무의미해지지,  저장해서 넣었다 뺏다 하려면 변수에 담으면 됨
 * 식별자 타입
 : 값의 특징에 따라 복사가 되기도 참조가 되기 한다. 
  * 기본형(값) : 복사를 일으키는 값 = primitive type // number, string, boolean, undefined, null, symbol
  * 참조형 : 다른 메모리 주소 값. = reference type
  * 기준이 왜!!! 
   * artificial language - 인공언어 .. 자연어에 비해서 인공어는 사람이 설계했그 . 그사람이 정해버렸으니 그렇게 .. ex) 자바에서 string은 참조형
 * 변수 
  * 메모리 주소의 별명(메모리 주소를 알고있다)
  * 해당 값의 타입정보를 가지고 있다.. (변수를 데이터라고도 옛날에 옛날에 그랬그 .. 그래서 데이터 타입이라는 말이 나왔그 )
 * 상수 
 : 변화가능성을 줄임으로써 복잡성을 낮추기 위해 상수가 존재! 
 

### sync flow
* 노이만머신 - 같은 메모리상에 operand(데이터)와 명령어가 같이 존재.
: 시작하면 프로그램 메모리에 적재되있는것을 우리의 관여를 거부하고 한번에 쭉 실행 - 끝 (중간에 개입 불가) -> flow 
 * 동기화 과정 
 : 적재된 프로그램이 소비되는 과정.. 프로그램이 계속 cpu한테 소비되고 있는 상황
 * 비동기성 : 어긋나게 소비?

* lr parser 
: 프로그램이 좌에서 우로 해석됨(양키양키함)
 * 할당연산자 a = 3 -> 오른쪽에서 왼쪽으로 들어오는 경우 유일.. (수학규칙. 수학자가 개발한 티를 냄..)
 * 연산자가 주입된건 무조건 괄호로 묶는다 -> 함정에 빠질 수 있는건 다 막아라. 방어적 코드를 확실히! 명확한 표현 중요!!!!

* flow를 제어하고싶어! 입력값에 따라 다르게 작동하는 flow를 만들고 싶어!! 
-> flow control statement! : sync flow control statement
-> sub flow contol // 함수, 클래스 에서 처리 - 반복적으로 제어하고 싶을 때 ,, 

문이나 식을 조직화 = flow control

* 루틴 : 플로우 한세트가 진행되는 것.
* 서브루틴 : 서브플로우가 진행되는 것. 
* 코루틴 ??


### 제어문
if 가 있는데 switch 가 있어. 왜 만들었을까? -> 사람의 의도를 표현하기 위해 .. 
제어문에 똑같은 표현이 들어가 있는 이유 -> 코드를 작성할 때 의도를 표현하기 위해 , 다음에 코드를 이해하기 위해.
제어문을 공부해서 섬세하게 표현하자,, 
* if문 
 * if 다음에 공백은 무제한으로 올 수 있다.  문제 없다.  자바스크립트 엔진이 읽을 수 있으면 됨
 * if ( ex ) st  , if ( ex ) { st }  , if ( ex ) st else st
 * if ( 식 ) 문                 블럭
 * if 문 괄호안에 식이 참이면 괄호  다음 문장이 실행될거야 . 옵셔널. 선택적. 
 * if else 문 도망갈 곳이 없다. 필수 멘데토리 if 아니면 else에 가둬짐,, 
 * ( ) 세 가지 의미 - 우선순위 연산자, 제어문에 들어가는 형식기호, 함수 호출식 연산자
